#!/usr/bin/env sh

set -e

show_help () {
  cat << EOF >&2
checkvolumesize 1.0.1

Automatically expand Digital Ocean block storage volumes

Usage: checkvolumesize [options]

Options:

  --help | -h | help    [Optional] Show this help message
  --token               [Required] Digital Ocean API token
  --device              [Required] The volume's block device or mount point
  --volume-name         [Required] The volume's name
  --volume-region       [Required] The volume's region
  --buffer              [Optional] The amount of GB to keep available    Default: 10
  --log                 [Optional] Prepend timestamps to stdout

Example:

  checkvolumesize \\
    --token bc99be9f73b037da64074472fe58f643e619328b85c5467615964a59abd12029 \\
    --device /mnt/block-storage \\
    --volume-name volume-sgp1-01 \\
    --volume-region sgp1 \\
    --buffer 10

GitHub: https://github.com/lukechilds/autoscale-do-block-storage

EOF
}

# If no arguments passed, show help and exit
if [ $# -le 0 ]; then
  show_help
  exit 1
fi

# Holders for all arguments passed (w/defaults set when defined)
TOKEN=
DEVICE=
VOLUME_NAME=
VOLUME_REGION=
BUFFER=10
LOG=

log () {
  prefix=""
  if [ "$LOG" = true ]; then
    prefix="$(date "+%Y-%m-%d %H:%M:%S") "
  fi

  >&2 echo "${prefix}$*"
}

error () {
  >&2 echo
  log "ERROR: $*"
}

help_error () {
  error "$*"
  >&2 echo
  show_help
}

while true; do
  # no parameters remaining -> end option parsing
  if [ $# -le 0 ]; then
    break
  fi

  opt="$1"

  # Handle fmt: `--buffer=10`; Split `opt` on `=` into `opt` & `value`
  #   NOTE: prepended with `=`, because if `-d` isn't found, `cut` ignores `-f`, and returns the whole string regardlessâ€¦
  value="$(echo "=$opt" | cut -d= -f3-)"
  if [ -n "$value" ]; then
    opt="$(echo "=$opt" | cut -d= -f2)"
  fi

  # Handle fmt: `--buffer 10`; Leave `opt` as-is, and try to get `value` from next arg
  #   NOTE: only do it when next arg doesn't start with `-`
  if [ -z "$value" ] && [ "$2" = "${2#-}" ]; then
    value="$2"
    shift
  fi

  # Remove the arg that was just used up
  #   NOTE: `|| true` because `shift` returns non-zero on no arguments & `--help` gets no arguments
  shift || true

  case "$opt" in
    -h|-?|--help|help)
      show_help
      exit 0
      ;;

    --token)         TOKEN="$value" ;;
    --device)        DEVICE="$value" ;;
    --volume-name)   VOLUME_NAME="$value" ;;
    --volume-region) VOLUME_REGION="$value" ;;
    --buffer)        BUFFER="$value" ;;
    --log)           LOG=true ;;

    *)
      help_error "Unknown option: \"$opt\""
      exit 1
      ;;
  esac
done

check_root () {
  if [ "$(id -u)" != "0" ]; then
    error "This script must be run as root"
    exit 1
  fi
}

check_dependencies () {
  for cmd in "$@"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      error "This script requires \"${cmd}\" to be installed"
      exit 1
    fi
  done
}

check_options () {
  if [ -z "$TOKEN" ] || [ -z "$DEVICE" ] || [ -z "$VOLUME_NAME" ] || [ -z "$VOLUME_REGION" ]; then
    help_error 'You are missing required options'
    exit 1
  fi
}

digital_ocean_api () {
  endpoint=$1
  post_data=$2

  # If `post_data` provided, method=POST, otherwise method=GET
  method="${post_data:+POST}"
  method="${method:-GET}"

  # If set, prepend `post_data` with `-d `
  post_data="${post_data:+-d $post_data}"

  curl --silent \
    -X "$method" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer ${TOKEN}" \
    "$post_data" \
    "https://api.digitalocean.com/v2/${endpoint}"
}

kilobytes_to_gigabytes () {
  kilobytes=$1

  echo $(( kilobytes / 1024 / 1024 ))
}

check_device_free_space () {
  device=$1

  bytes_free=$(df --output=avail "$device" | tail -n 1)
  kilobytes_to_gigabytes "$bytes_free"
}

mountpoint_to_device () {
  mountpoint=$1

  df --output=source "$mountpoint" | tail -n 1
}

main () {
  check_root
  check_dependencies curl jq resize2fs
  check_options

  # Check available volume space
  log "Checking available space on device \"${DEVICE}\" is above ${BUFFER}GB requirement..."
  volume_free_space=$(check_device_free_space "$DEVICE")
  if [ "$volume_free_space" -gt "$BUFFER" ]; then
    log "${volume_free_space}GB available, all good!"
    return
  fi
  log "Only ${volume_free_space}GB available, volume resize required"

  # Save start time
  start_time="$(date +%s)"

  # Get volume data
  log "Getting data for volume \"${VOLUME_NAME}\" in region \"${VOLUME_REGION}\"..."
  volume_json=$(digital_ocean_api "volumes?region=${VOLUME_REGION}" | jq -r ".volumes[] | select(.name==\"${VOLUME_NAME}\")")
  volume_id=$(echo "$volume_json" | jq -r .id)
  volume_size=$(echo "$volume_json" | jq -r .size_gigabytes)
  log "Volume ID is \"${volume_id}\" and is currently ${volume_size}GB"

  # Increase volume size
  new_volume_size=$(( volume_size + BUFFER ))
  log "Increasing volume size to ${new_volume_size}GB..."
  action_json=$(digital_ocean_api "volumes/${volume_id}/actions" '{"type":"resize","size_gigabytes":'$new_volume_size'}')
  action_id="$(echo "$action_json" | jq -r '.action.id')"
  log "Created action \"${action_id}\""

  # Wait for volume resize
  log "Waiting for action to complete..."
  while true; do
    resize_status=$(digital_ocean_api "actions/$action_id" | jq -r '.action.status')
    if [ "${resize_status}" = "completed" ]; then
      break
    fi

    >&2 printf '.' # for progress
    sleep 1
  done
  log "Volume resize complete!"

  # Resize filesystem
  log "Resizing filesystem..."
  sudo resize2fs "$(mountpoint_to_device "$DEVICE")" 2>&1 | while read -r line; do
    if [ "${line}" != "" ]; then
      log "$line"
    fi
  done
  log "Filesystem resize complete!"

  # Show new available space on completion
  new_free_space=$(check_device_free_space "$DEVICE")
  log "Device \"${DEVICE}\" now has ${new_free_space}GB available"

  # Show duration
  now="$(date +%s)"
  duration=$(( now - start_time ))
  log "Completed in ${duration} seconds"
}

main
